<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on 加蛋加葱花～</title>
    <link>http://localhost:1313/tags/swift/</link>
    <description>Recent content in Swift on 加蛋加葱花～</description>
    <generator>Hugo</generator>
    <language> zh_CN</language>
    <lastBuildDate>Tue, 06 Feb 2024 10:51:53 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Swift_shim_name</title>
      <link>http://localhost:1313/posts/swift_shim_name/</link>
      <pubDate>Tue, 06 Feb 2024 10:51:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/swift_shim_name/</guid>
      <description>Swift Shim 名词&#xA;Swift 源代码中用看到 SwiftShim，但是不知道它具体的意思。&#xA;Swift 社区有人解释：&#xA;“Shim”是一个比较常见的编程术语，意味着轻量级。它主要用于兼容层，用于纠正平台之间的差异。&#xA;参考 https://forums.swift.org/t/swift-shims/3677/3</description>
    </item>
    <item>
      <title>Swift_lazy_collection</title>
      <link>http://localhost:1313/posts/swift_lazy_collection/</link>
      <pubDate>Wed, 17 Jan 2024 13:49:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/swift_lazy_collection/</guid>
      <description>Swift lazy collections Swift lazy collections 会延迟操作。这对于大集合来说，可以减少内存的使用和提高性能。但是，对于简单的集合，我们使用数组的效率会更高。&#xA;let numbers = [1, 2, 3].lazy.map { $0 * $0 } print(numbers) // LazyMapCollection&amp;lt;Array&amp;lt;Int&amp;gt;, Int&amp;gt; 参考 Add a Lazy flatMap for Sequences of Optionals&#xA;Use Lazy Collections in Swift</description>
    </item>
    <item>
      <title>Swift_propertywrapper</title>
      <link>http://localhost:1313/posts/swift_propertywrapper/</link>
      <pubDate>Fri, 22 Sep 2023 21:04:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/swift_propertywrapper/</guid>
      <description>swift propertyWrapper 日常的开发之前，我们常常要对属性做一下限制。比如考试的分数最高分是 100 分，因此我们的分数不能大于 100。&#xA;为此，我们要写为：&#xA;class Exam { private var _score: Float = 0 var score: Float { set(score) { if score &amp;lt; 0 { _score = 0 } else if score &amp;gt; 100 { _score = 100 } else { _score = score } } get { _score } } } 这样我们编写大量的代码去处理这些相同的情况，不够简洁和不易理解。&#xA;propertyWrapper 提供这样的一种机制：在属性存取上加一层，可以方便地处理这些情况。&#xA;propertyWrapper 的使用 @propertyWrapper struct ExamWrapper { private var value: Float = 0.0 var wrappedValue: Float { set { if newValue &amp;lt; 0 { value = 0 } else if newValue &amp;gt; 100 { value = 100 } else { value = newValue } } get { value } } init(wrappedValue: Float) { self.</description>
    </item>
    <item>
      <title>Swift_rethrows</title>
      <link>http://localhost:1313/posts/swift_rethrows/</link>
      <pubDate>Wed, 20 Sep 2023 08:07:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/swift_rethrows/</guid>
      <description>swift rethrows rethrows 顾名思义是传递异常的意思。&#xA;使用场景：当函数参数为异常函数时，函数本身不会抛出异常，可以用 rethrows。&#xA;比如：&#xA;func log(complete: ( ( () throws -&amp;gt; Void ) )) -&amp;gt; rethrows { try complete() } 用法：&#xA;log() { } try log() { try ... } </description>
    </item>
  </channel>
</rss>
